%%
\documentclass[format=draft,language=chinese,category=SDN]{hustreport}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
}
\lstset{language=sh,columns=fullflexible,frame=single}
\newcommand{\myparagraph}[1]{\paragraph{#1}\mbox{}\\}
\newcommand{\code}{\texttt}

\title{初赛文档}
\author{\kai{林家军}~~\kai{李英儒}~~\kai{胡云锐}}
\major{计算机科学与技术}
\department{计算机科学与技术学院}
\advisor{\kai{周世伟}}

\abstract{
    这是来自华中科技大学UniqueSDNStudio队伍的初赛文档，于\LaTeX{}编辑而成。

}
\keywords{软件定义网络, SDN, \LaTeX{}， 华中科技大学}


\begin{document}
\nocite{*}

\frontmatter
\maketitle
\makeabstract
\tableofcontents
\listoffigures
\listoftables
\mainmatter

\chapter{基础环境}\label{chapter:BaiscEnv}
SDN 的基础环境由 SDN 控制器(Controller)和支持 SDN 的交换机构成
的网络组成,我们在本次比赛中使用 Ryu 作为 SDN 控制器,使用 Mininet 构建
虚拟试验网络。
\section{Ryu}
Ryu is a component-based software defined networking framework.

Ryu是一个基于组件的软件定义网络框架。

Ryu provides software components with well defined API that make it easy for developers to create new network management and control applications. Ryu supports various protocols for managing network devices, such as OpenFlow, Netconf, OF-config, etc. About OpenFlow, Ryu supports fully 1.0, 1.2, 1.3, 1.4 and Nicira Extensions.

Ryu提供了具有良好设计的API结构的软件组件，使得开发者能够更加方便简单地创建新的网络管理控制应用。Ryu支持许多管理网络设备的协议，例如OpenFlow, Netconf, OF-config等。关于Openflow，Ryu支持全部1.0， 1.2， 1.3， 1.4和Nicira扩展。

All of the code is freely available under the Apache 2.0 license. Ryu is fully written in Python.

所有Ryu代码能够在Apache 2.0 许可下自由地获取。 Ryu全部由Python写成。

\section{Mininet}
Mininet 是由一些虚拟的终端节点(end-hosts)、交换机、路由器连接而成的一个网络仿真器,它采用轻量级的虚拟化技术使得系统可以和真实网络相媲美。它可以很方便的创建一个支持 SDN 的网络,有了这个网络,就可以灵活的为网络添加新的功能并进行相关测试。

\chapter{参赛情况}\label{chapter:Situation}


\section{竞赛组织及参与情况}
本次竞赛的组织活动由校教务处发起,在全校范围内自主报名参加。联创团队组织三名大二学生参赛,并安排一位研究生作为领队。在参赛过程中,每周每人大约工作时间 40 小时且每周六进行一次讨论总结上周情况并对下周进行科学严谨的安排,为保证作品按时完成我们建立了邮件列表与在线讨论平台,同一管理协调。
\section{参赛队伍构成}
\subsection{联创团队}
联创团队$(Unique Studio)$于 2000 年 6 月创建于华中科技大学,是 $Teamwork$ 和
 $Creation$ 为团队核心的学生团队。团队名称来源于“联众人之智”必能“创辉煌之事”的信念
。联创团队建立了一个自主的精英学生平台,在这个平台上学生自我管理,通过这个平台激发无限的潜力和创意。
自成立到现在,联创团队已参加微软创新杯 11 次并 8 次进入全球总决赛拿下包括全球冠军等优秀成绩。
除此之外,联创团队也多次参加各种大小型比赛并取得了骄人的成绩,并与$MICROSOFT$\texttrademark、$CSDN$\texttrademark 等公司保持着非常好的合作关系,同时加入微软中国组织的创新联盟。
联创团队多年的发展积累了独特的文化和运作机制,同时跟踪技术发展的最前沿,这使得联创团队在华科乃至全国高校中独树一帜。
\subsection{领队}
\kai{周世伟}

\textbf{华中科技大学} 2010级本科生，2014 级研究生,现就读于光电与电子信息学院光电信息工程专业。华中科技大学联创团队 IT 组和嵌入式组成员。曾 2 次获得国家奖学金。参与 微软创新杯$Imagine~Cup\texttrademark$ $IT~Challenge\textregistered$ 比赛,并进入中国区总决赛。曾获得
中国区第一届 $RDMA\textregistered$ 比赛一等奖。目前已获得华中科技大学保研资格。
\href{http://zhoushiwei1992.blog.163.com}{周世伟个人博客。}
\subsection{参赛队员}
\kai{林家军}

\textbf{华中科技大学} 2013 级本科生,现就读于计算机科学与技术学院计算机科学与技术专业。华中科技大学联创团队 IT 组成员。

\kai{李英儒}

\textbf{华中科技大学} 2013 级本科生,现就读于计算机科学与技术学院计算机科学与技术专业。华中科技大学联创团队 IT 组成员。

\kai{胡云锐}

\textbf{华中科技大学} 2013 级本科生,现就读于计算机科学与技术专业。
华中科技大学联创团队 IT 组成员,主要进行网络通讯、大数据方面的研究。

\chapter{初赛题目}\label{chapter:Questions}


\section{第一题:基础题}\label{sec:Q1}
\subsection{第1小题：简单网络}\label{sec:Q1_1}

\begin{figure}[!h] \centering
\includegraphics[width=.618\textwidth]{fig/1_1-0.png}
\caption{第一题第1小题：简单网络}\label{fig:Q1_1-0}
\end{figure}

\myparagraph{网络环境要求}

要求搭建的网络环境如图 1 所示(Controller 表示控制器, switch 表示交换机, host表示主机)。控制器可以自主选择,例如各种开源的控制器(Floodlight、Ryu、
Nox、Beacon、Trema、OpenDaylight 等)。拓扑中各网络部件既可以是仿真环境实现(例如 mininet, OpenvSwtich 等),有条件的队伍也可以通过物理设备实现,
各种方案不影响评分。试题中每道题都遵循这些要求,不再说明。

\myparagraph{操作要求}

1.先使 Host1 可以 ping 通 Host2,Host2 也可以 ping 通 Host1。

2.然后对流表进行操作,使 Host1 不能 ping 通 Host2, Host2 也不能 ping 通 Host1。

\myparagraph{方法描述}

利用 mininet 创建虚拟环境，在虚拟交换机上直接修改流表。

\myparagraph{实验步骤}

1. 打开 mininet 创建一个拓扑，它包含一个交换机和两个主机。命令如下:

\begin{lstlisting}
mn --topo single,2
\end{lstlisting}

2. 在 mininet CLI 中检查环境，确认流表为空。

3. 执行如下两条命令，添加流表，使两个虚拟主机可以通信。

\begin{lstlisting}
s1 ovs-ofctl add-flow "s1" in_port=1,action=output:2
s1 ovs-ofctl add-flow "s1" in_port=2,action=output:1
\end{lstlisting}

4. 执行 \code{pingall} 检查网络环境，结果见\autoref{fig:Q1_1-1}，h1 与 h2 可以正常通信。

\begin{figure}[!h]
\centering
\includegraphics[width=.618\textwidth]{fig/1_1-1.png}
\caption{检查虚拟网络环境}\label{fig:Q1_1-1}
\end{figure}

5. 执行如下两条命令，删除添加的流表。

\begin{lstlisting}
s1 ovs-ofctl del-flows "s1" in_port=1
s1 ovs-ofctl del-flows "s1" in_port=2
\end{lstlisting}

6. 执行 \code{pingall} 再次检查网络环境，结果见\autoref{fig:Q1_1-2}，h1 与 h2 无法正常通信。

\begin{figure}[!h]
\centering
\includegraphics[width=.618\textwidth]{fig/1_1-2.png}
\caption{删除流表后检查虚拟网络环境}\label{fig:Q1_1-2}
\end{figure}

\myparagraph{实验结果}

通过修改交换机的流表，先后成功实现虚拟主机 h1 与 h2 能互相 ping 通，与 ping 不通。


\subsection{第2小题：访问限制}\label{sec:Q1_2}

\begin{figure}[!h]
\centering
\includegraphics[width=.618\textwidth]{fig/1_2-0.png}
\caption{第一题第1小题：访问限制}\label{fig:Q1_2-0}
\end{figure}

\myparagraph{网络环境要求}

设有一台 PC 机(Host1),一台 Web 服务器(Server1)提供简单的静态网页访问服务,如图 2 所示。(PC 机、Web 服务器、交换机、控制器可以选择物理设备或者虚拟设备实现)

\myparagraph{操作要求}

1.先使得 PC 机访问服务器成功(即看到服务器的网页)。

2.限制该 PC 机一定时间(比如一分钟)内再次访问服务器。限制时间过后,PC机可以成功访问服务器。

\myparagraph{方法描述}

拓扑环境如\autoref{fig:Q1_2-0}，其中 h1 为客户机，h2 为服务器。
为了一般性，我们编写了第三方 Ryu Controller App, 接收交换机连接 Controller 时发来的 Feature message, 并为交换机添加默认流表。
首先保证主机 h1 和 h2 的正常通信，如果匹配到 h1 发来的 TCP 包，在送出 2 号端口的同时复制一份送给 Controller。
Controller分析后，判断此包来源的 mac 是否在白名单中；若不在，放行 TCP 包 ACK 标志小于等于 1 的包，为交换机添加一个带有 60 秒 hard\_timeout 的 flow entry，丢弃所有来自此 mac 并且目的 mac 地址是主机 h2 的 http 包，同时将此 mac 加入白名单。
60 秒过后，此 flow entry 过期，而来源 mac 已在白名单中，下次请求将不会阻止。

\myparagraph{实验步骤}

1. 执行如下命令，其中 setup\_network.py 用于搭建虚拟网络环境，执行该脚本需要 root 权限。1\_2.py 是我们编写的 Ryu Controller App。

\begin{lstlisting}
python2 setup_network.py
ryu-manager 1_2.py
\end{lstlisting}

交换机连接 Controller 后，会往 Controller 发送 Feature message，以下代码将发挥作用。

\begin{lstlisting}[language=python]
...
    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)
    def switch_feature_handler(self, ev):
        datapath = ev.msg.datapath
        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser
        dpid = datapath.id

        self.logger.info("Switch %d connected, adding flow entries.", dpid)
        match = parser.OFPMatch(in_port=1)
        actions = [parser.OFPActionOutput(2, ofproto.OFPCML_NO_BUFFER)]
        # Flow entry match structure: priority=0,in_port=1 actions=output:2
        self.add_flow(datapath, 0, match, actions)

        match = parser.OFPMatch(in_port=2)
        actions = [parser.OFPActionOutput(1, ofproto.OFPCML_NO_BUFFER)]
        # Flow entry match structure: priority=0,in_port=2 actions=output:1
        self.add_flow(datapath, 0, match, actions)

        if dpid == 2:
            match = parser.OFPMatch(in_port=1, eth_type=PROTO_IP,
                                    ip_proto=PROTO_TCP, tcp_dst=80)
            actions = [parser.OFPActionOutput(2, ofproto.OFPCML_NO_BUFFER),
                       parser.OFPActionOutput(ofproto.OFPP_CONTROLLER,
                                              ofproto.OFPCML_NO_BUFFER)]
            # Flow entry match structure:
            # priority=1,tcp,in_port=1,tp_dst=80
            # actions=output:2,CONTROLLER:65535
            self.add_flow(datapath, 1, match, actions)

...
\end{lstlisting}

2. 在 mininet CLI 中检查网络环境，结果如\autoref{fig:Q1_2-1}。

3. 在 mininet CLI 中执行 \code{h2 xterm \&}，并在打开的 xterm 中执行 \code{python -m HTTPServer 80} 打开 Web 服务器。

4. 回到 mininet CLI 中执行 \code{h1 curl h2}, 得到以下返回
\begin{center}
**this\_is\_the\_web\_page\_of\_problem\_1.2**
\end{center}
一分钟内再次执行 \code{h1 curl h2 -m 10}，超时。检查流表，结果如\autoref{fig:Q1_2-2}。

Controller 接受到 PacketIn message 时，以下代码将会发挥作用。

\begin{lstlisting}[language=python]
...
    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)
    def _packet_in_handler(self, ev):
        msg = ev.msg
        datapath = msg.datapath
        parser = datapath.ofproto_parser
        in_port = msg.match['in_port']
        dpid = datapath.id
        pkt = packet.Packet(msg.data)
        eth = pkt.get_protocols(ethernet.ethernet)[0]
        dst = eth.dst
        src = eth.src
        tcp_p = pkt.get_protocols(tcp.tcp)

        if dpid != 2 or src in self.macs or len(tcp_p) == 0:
            return

        tcp_p = tcp_p[0]
        if tcp_p.ack <= 1:  # TCP three-way handshake and HTTP request
            return

        self.logger.info("First HTTP request from %s, adding flow entry.", src)

        self.macs.append(src)
        actions = []
        match = parser.OFPMatch(in_port=in_port, eth_src=src, eth_dst=dst,
                                eth_type=PROTO_IP, ip_proto=PROTO_TCP,
                                tcp_dst=80)
        # Flow entry match structure:
        # priority=2,tcp,in_port=1,dl_src=xx:xx:xx:xx:xx:xx,
        # dl_dst=xx:xx:xx:xx:xx:xx,tp_dst=80 actions=drop
        self.add_flow(datapath, 2, match, actions, hard_timeout=60)

...
\end{lstlisting}

\global\csname @topnum\endcsname 0 % prevent figures breaking lstlisting

\begin{figure}[!h]
\centering
\includegraphics[width=.618\textwidth]{fig/1_2-1.png}
\caption{检查网络环境}\label{fig:Q1_2-1}
\end{figure}

\begin{figure}[!h]
\centering
\includegraphics[width=.618\textwidth]{fig/1_2-2.png}
\caption{}\label{fig:Q1_2-2}
\end{figure}

5. 等待 60 秒，多次执行 \code{h1 curl h2}，均能得到正常返回
\begin{center}
**this\_is\_the\_web\_page\_of\_problem\_1.2**
\end{center}
此时再检查流表，发现第 4 步时新增的流表已经过期。结果见\autoref{fig:Q1_2-3}

\begin{figure}[!h]
\centering
\includegraphics[width=.618\textwidth]{fig/1_2-3.png}
\caption{流表过期}\label{fig:Q1_2-3}
\end{figure}

\myparagraph{实验结果}

利用 Ryu Controller 提供的 Python API，自动化实现问题要求。

\section{第二题:提高题}\label{sec:Q2}
\subsection{第1小题：代理访问}\label{sec:Q2_1}

\begin{figure}[!h]
\centering
\includegraphics[width=.618\textwidth]{fig/2_1-0.png}
\caption{第二题第1小题：代理访问}\label{fig:Q2_1-0}
\end{figure}

\myparagraph{网络环境要求}

设有两台 PC 机(Host1,Host2),一台 Web 服务器(Server1)提供简单的静态网页访问服务,一台代理服务器(Proxy1)和 Web 服务器提供同样的服务,两
台服务器所显示的网页大致相同,但要有显著差别,可以是不同的网页内容或者不同颜色,能够区分彼此即可,如图 3 所示。(PC 机、Web 服务器、代理服务器、交换机、控制器可以选择物理设备或者虚拟设备实现)

\myparagraph{操作要求}

1.Web 服务器是 Host1 和 Host2 都可以访问的,而代理服务器是只有代理用户才可以使用。

2 可以设置 Host1 或 Host2 为代理用户,可以直接从代理服务器访问到网页。

\myparagraph{方法描述}

为了一般化，本题同样用 Ryu Controller Python API 实现。采用 Ryu 内置的 simple\_switch\_13 简单处理路由。编写第三方 Ryu Controller App，在交换机 s3 连接 Controller 时为其添加默认流表，丢弃所有来自 h2 并且发往 h4 的数据包。

\myparagraph{实验步骤}

1. 执行如下命令，其中 setup\_network.py 用于搭建虚拟网络环境，执行该脚本需要 root 权限。2\_1.py 是我们编写的 Ryu Controller App。

\begin{lstlisting}
python2 setup_network.py
ryu-manager 2_1.py ryu.app.simple_switch_13
\end{lstlisting}

交换机连接 Controller 后,会往 Controller 发送 Feature message。此时 Ryu 的 simple\_switch\_13 和 2\_1.py 中注册的回调都会被调用。2\_1.py 中往 s3 交换机添加流表的如下代码将会发挥作用。

\begin{lstlisting}
...
    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)
    def switch_feature_handler(self, ev):
        datapath = ev.msg.datapath
        parser = datapath.ofproto_parser
        dpid = datapath.id

        print 'Switch s%d connected.' % dpid
        if dpid == 3:
            match = parser.OFPMatch(in_port=1,
                                    eth_src=self.h2_mac, eth_dst=self.h4_mac)
            actions = []  # Drop
            # Flow entry:
            # table=0, priority=65535,in_port=1,dl_src=00:00:00:00:00:02,
            # dl_dst=00:00:00:00:00:04
            # actions=drop
            self.add_flow(datapath, 65535, match, actions)

...
\end{lstlisting}

2. 在 mininet CLI 中检查网络环境，输出流表如\autoref{fig:Q2_1-1}，其中
\begin{center}
priority=65535,in\_port=1,dl\_src=00:00:00:00:00:02,dl\_dst=00:00:00:00:00:04 actions=drop
\end{center}

为 2\_1.py 为交换机 s3 添加的默认流表。

\begin{figure}[!h]
\centering
\includegraphics[width=.618\textwidth]{fig/2_1-1.png}
\caption{输出流表}\label{fig:Q2_1-1}
\end{figure}

3. 在 mininet CLI 中执行 pingall，检查网络环境，结果如\autoref{fig:Q2_1-2}，simple\_switch\_13 添加了多个流表保证网络通信。只有 h2 与 h4 互相无法 ping 通。

\begin{figure}[!h]
\centering
\includegraphics[width=\textwidth]{fig/2_1-2.png}
\caption{pingall结果与流表变化}\label{fig:Q2_1-2}
\end{figure}

\begin{figure}[!h]
\centering
\includegraphics[width=.618\textwidth]{fig/2_1-3.png}
\caption{h1 h2 分别请求 h3 h4 网页的结果}\label{fig:Q2_1-3}
\end{figure}

4. 搭建 Web 服务器。先在 mininet CLI 中执行 \code{h3 xterm \&}, 在打开的 xterm 中执行 \code{cd web \&\& python -m SimpleHTTPServer 80}，再在 mininet CLI 中执行 \code{h4 xterm \&}, 在打开的 xterm 中执行 \code{cd proxy \&\& python -m SimpleHTTPServer 80}，至此，Web Server 和 Web Proxy Server 搭建完毕。

5. 回到 mininet CLI 分别执行如下命令，得到输出如\autoref{fig:Q2_1-3}，说明只有 h2 无法访问 h4(proxy)。

\begin{lstlisting}
h1 curl h3 -m 10
h1 curl h4 -m 10
h2 curl h3 -m 10
h2 curl h4 -m 10
\end{lstlisting}

\myparagraph{实验结果}

利用 Ryu Controller 提供的 Python API,自动化实现问题要求。

\subsection{第2小题：流表管理}\label{sec:Q2_2}

\begin{figure}[!h]
\centering
\includegraphics[width=.618\textwidth]{fig/2_2-0.png}
\caption{第二题第2小题：流表管理}\label{fig:Q2_2-0}
\end{figure}

\myparagraph{网络环境要求}

设有若干台 PC 机(Host1,Host2),若干台交换机(Switch1,Switch2),如图 4所示(作为示例拓扑,实际拓扑可自由选择)。(PC 机、交换机、控制器可以选择物理设备或者虚拟设备实现)

\myparagraph{操作要求}

利用控制器提供的 API(例如 REST API),开发一个网络及流表管理工具(客户端,网页端均可)。管理工具可以显示网络拓扑结构,查看流表,增加流表,删除流表。


\section{第三题:设计题}\label{sec:Q3}

\subsubsection{第三层}\label{sec:3}
测试测试测试测试测试测试测试测试测试测试测试测试。
\footnote{\label{footnote:1}脚注}

\section{字体}

普通\textbf{粗体}\emph{斜体}

\hei{黑体}\kai{楷体}\fangsong{仿宋}

\section{公式}

单个公式，公式引用：\autoref{eq:1}。
\begin{equation}
 c^2 = a^2 + b^2 \label{eq:1}
\end{equation}

多个公式，公式引用：\autoref{eq:2}，\autoref{eq:3}。

\begin{subequations}
\begin{equation}
  F = ma \label{eq:2}
\end{equation}
\begin{equation}
  E = mc^2 \label{eq:3}
\end{equation}
\end{subequations}

\section{罗列环境}

\begin{enumerate}
    \item 第一层\label{item:1}
    \item 第一层
    \begin{enumerate}
        \item 第二层\label{item:2}
        \item 第二层
        \begin{enumerate}
            \item 第三层\label{item:3}
            \item 第三层
        \end{enumerate}
    \end{enumerate}
\end{enumerate}

\begin{description}
    \item[解释环境]  解释内容
\end{description}

\chapter{其他格式测试}

\section{代码环境}

\begin{lstlisting}[language=python]
import os

def main():
    '''
    doc here
    '''
    print 'hello, world' # Abc
    print 'hello, 中文' # 中文
\end{lstlisting}

\section{定律证明环境}

\begin{definition}\label{def:1}
这是一个定义。
\end{definition}
\begin{proposition}\label{proposition:1}
这是一个命题。
\end{proposition}
\begin{axiom}\label{axiom:1}
这是一个公理。
\end{axiom}
\begin{lemma}\label{lemma:1}
这是一个引理。
\end{lemma}
\begin{theorem}\label{theorem:1}
这是一个定理。
\end{theorem}
\begin{proof}\label{proof:1}
这是一个证明。
\end{proof}

\section{算法环境}

\begin{algorithm}[H]
\SetAlgoLined
\KwData{this text}
\KwResult{how to write algorithm with \LaTeX2e }
initialization\;\label{alg_line:1}
\While{not at end of this document}{
read current\;
\eIf{understand}{
go to next section\;
current section becomes this one\;
}{
go back to the beginning of current section\;
}
}
\caption{How to write algorithms}\label{alg:1}
\end{algorithm}

\section{表格}
表格见\autoref{tab:1}。

\begin{table}[!h]
\centering
\caption{一个表格}\label{tab:1}
\begin{tabular}{|c|c|}
\hline
a & b \\
\hline
c & d \\
\hline
\end{tabular}
\end{table}
\section{图片}
图片见\autoref{fig:1}。图片格式支持eps，png，pdf等。多个图片见\autoref{fig:2}，分开引用：\autoref{fig:2-1}，\autoref{fig:2-2}。

\begin{figure}[!h]
\centering
\includegraphics[width=.4\textwidth]{fig/fig-example.pdf}
\caption{一个图片}\label{fig:1}
\end{figure}

\begin{figure}[!h]
\centering
  \begin{subfigure}[b]{0.3\textwidth}
  \includegraphics[width=\textwidth]{fig/fig-example.pdf}
  \caption{图片1}\label{fig:2-1}
  \end{subfigure}
  ~
  \begin{subfigure}[b]{0.3\textwidth}
  \includegraphics[width=\textwidth]{fig/fig-example.pdf}
  \caption{图片2}\label{fig:2-2}
  \end{subfigure}
\caption{多个图片}\label{fig:2}
\end{figure}

\section{参考文献示例}
这是一篇中文参考文献\cite{TEXGURU99}；这是一篇英文参考文献\cite{knuth}；同时引用\cite{TEXGURU99,knuth}。

\section[\textbackslash{}autoref 测试]{\texttt{\textbackslash{}autoref} 测试}

\begin{description}
  \item[公式] \autoref{eq:1}
  \item[脚注] \autoref{footnote:1}
  \item[项] \autoref{item:1},\autoref{item:2},\autoref{item:3}
  \item[图] \autoref{fig:1}
  \item[表] \autoref{tab:1}
  \item[附录] \autoref{appendix:1}
  \item[章] \autoref{chapter:BaiscEnv}
  \item[小节] \autoref{sec:Q1},\autoref{sec:Q1_1},\autoref{sec:Q2}
  \item[算法] \autoref{alg:1},\autoref{alg_line:1}
  \item[证明环境] \autoref{def:1},\autoref{proposition:1},\autoref{axiom:1},\autoref{lemma:1},\autoref{theorem:1},\autoref{proof:1}
\end{description}

\backmatter

\begin{ack}
致谢正文。
\end{ack}

\bibliography{ref-example}

\appendix

\begin{publications}
    \item 论文1
    \item 论文2
\end{publications}

\chapter{这是一个附录}\label{appendix:1}
附录正文。


\end{document}
\endinput
%%
%% End of file `hustreport-zh-example.tex'.
